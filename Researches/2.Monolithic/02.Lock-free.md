---
sort: 2
---

# Lock-free 기법 연구

## MV-RLU

### 연구배경

매니코어 머신에서 멀티쓰레드는 공유된 자원(자료구조)을 동시에 접근하는 일이 자주 발생하며 동시에 실행되는 쓰레드 갯수가 증가할수록 시스템의 성능은 공유자원 접근 방법 (동기화 매커니즘)에 따라 크게 좌우된다. 운영체제, 데이터베이스 시스템, 네트워크 스택, 저장장치 시스템 등 대부분의 소프트웨어 설계에서 동기화 매커니즘은 필수적인 요소이며 성능에 큰 영향을 미친다. 최근 프로세서 코어 개수의 증가와 하드웨어 병렬성은 빠르게 발전하고 있지만 소프트웨어의 성능 확장성은 하드웨어 발전에 미치지 못한다. 동기화 방식에 따라 다음과 같은 다양한 알고리즘(Lock, Lock-free, Delegation-style, STM, RCU-style 등)이 존재하지만 최신 매니코어 머신의 하드웨어 성능에 비례하여 성능 확장성을 제공하는 알고리즘은 없다. 따라서 본 연구진은 최신 매니코어 머신에서 성능확장성을 제공할 수 있는 새로운 동기화 매커니즘인 MV-RLU (Multi version-Read Log Update)를 제안한다.
본 연구에서는 멀티쓰레드간 공유 자원 접근에 대하여 확장 가능한 동기화 기법을 개발하여 최신 매니코어를 효율적으로 활용하고 다양한 소프트웨어 구성 요소의 성능 향상을 꽤한다. 이를 위해 직관적인 사용자 프로그래밍 인터페이스를 제공하고 동기화 구조를 제공하는 확장성 있는 동시 자료구조 프레임워크(Scalable concurrent data structure framework)을 개발한다. 그리고 영구메모리상에서 사용자 데이터 손실을 방지하고 고성능의 매니코어 확장성 있는 트랜잭셔널 메모리 소프트웨어를 개발한다.   

### 연구 내용

MV-RLU는 이름에서 알 수 있듯이 RLU (Read Log Update)라는 기존 기법의 장점을 계승하고 성능을 크게 향상시켰다. MV-RLU의 구성요소는 멀티버전 로깅과 로그 버퍼의 재활용 정책이다. 멀티버전 로깅은 멀티쓰레드가 공유자원을 동시에 접근하도록 하는 메커니즘이다. 하나의 노드 또는 오브젝트를 버전 체인으로 연결하여 멀티버전화 하고 각 버전에 타임스탬프를 부여하여 각 쓰레드가 각자 적합한 버전을 접근할 수 있도록 하는 구조이다. 이 매커니즘은 전통적인 데이터베이스 시스템에서 지원하는 기법이지만 버전 체인 트레버스 비용과 로그 버퍼의 재활용 시 발생하는 성능 하락이 가장 큰 문제점으로 지적되었다.

![Fig1](/Data/images/02/02-02-01.png)

이와 같은 전통적인 멀티버전의 문제점을 해결하기 위하여 각 쓰레드별로 로그 버퍼 재활용을 병렬적으로 (concurrent GC) 수행하고 버전 체인 트레버스 비용을 줄이기 위해 로그 버퍼 재활용을 자동화 (autonomous GC) 시키고 타임스탬프 발행 비용을 최소화하기 위해 하드웨어 클럭 기반 (ORDO 기법 - “A Scalable Ordering Primitive for Multicore Machines” 논문) 타임스탬프를 차용하였다.
(그림 1)은 RLU 동기화 기법의 성능 병목현상 원인과 MV-RLU가 이를 극복하는 방안을 도시하였다. 그림에서 Tn은 쓰레드번호를 의미하며 try_lock(a)는 a객체에 대해 새로운 버전 생성을 시도하는 것을 의미한다. RLU의 경우 객체당 최대 2개의 버전을 유지한다. 따라서, 쓰레드 2(T2)가 a객체에 대하여 3번째 객체 생성을 시도하는 경우 quiescent state 검출과 객체의 이전 버전을 정리(빨간색 표시 구간)할 때 까지 대기하므로 요청 처리 지연이 발생한다 (그림 1 (a)). 반면, MV-RLU는 다수의 버전을 동시에 생성할 수 있으므로 지연 없이 쓰레드 2(T2)가 새로운 버전을 생성한다(그림 1 (b)). 본 연구는 448 코어에서 실험을 통해 관찰한 바에 따르면, RLU의 경우 이와 같은 지연시간이 CPU 실행시간의 99.6%를 차지한다.

![Fig2](/Data/images/02/02-02-02.png)

(그림 2)는 여러 쓰레드가 연결 리스트를 동시 접근하는 경우 MV-RLU가 동기화 하는 방식과 객체 구성에 대하여 도시하였다. 연결 리스트의 각 노드는 master object와 copy object로 구성된다. master object는 일반적인 메모리 할당 연산에 의하여 생성되며 copy object는 쓰레드가 try_lock을 성공하는 경우 해당 쓰레드의 circular log에 저장된다. copy object는 생성되는 시점에 p-pending 포인터에 의해 연결되며 생성한 쓰레드가 연산을 완료(commit)하는 시점에 p-copy 포인터로 옮겨진다. copy object는 커밋 타임스탬프(commit-ts)와 이전 버전 타임스탬프(older-ts) 정보를 유지하고 이전 버전 체인(p-older)으로 다수의 버전들이 연결된다. 타임스탬프 값이 무한대인 경우 아직 커밋이 완료되지 않았다는 의미이다. MV-RLU는 이와 같은 타임스탬프 순서를 통해 각 쓰레드에게 일관된 객체 정보를 제공한다. 각 쓰레드는 임계영역에 진입하는 시점에 개별 타임스탬프(local-ts)를 부여받으며 이를 통해 적절한 버전의 객체를 접근한다. 
(그림 2)는 b노드가 시간 30 시점에 삭제된 것을 예로 도시하였다. copy object인 a’은 타임스탬프 30에 생성되어서 다음 노드를 c로 포인팅하여 노드 b를 삭제하였다. 쓰레드 1(T1)의 local-ts는 10이므로 T1은 b노드 삭제 이전에 시작된 쓰레드이므로 a노드를 통해 b노드를 순회하지만 T2의 경우 local-ts가 40이므로 타임스탬프 40이후에 생성된 a’을 접근하고 다음 노드로 c를 순회한다. 이와 같은 방식으로 각 쓰레드는 여러 버전이 있는 객체에 대하여 일관된 뷰를 가질 수 있다.

* MV-RLU optimized B-tree

* MV-RLU optimized ART

* Kyoto-Cabinet 적용

MV-RLU 기술을 오픈소스 키벨류 스토어 Kyoto-Cabinet에 적용한 소프트웨어도 상기 깃허브에 공개하였다.

### 실험

MV-RLU 성능 평가를 위해 8소켓 448 코어(물리적으로는 224 코어)의 Intel Xeon Platinum 8180 CPU(2.5GHz)와 337GB DRAM이 장착된 서버를 사용하였다. 실험에서는 다양한 자료구조(Linked list, Hash table, Binary search tree)를 접근하는 마이크로 벤치마크와 실제 응용 워크로드를 통해 성능평가를 실시하였다. 비교대상 동기화 기법으로는 RCU, RLU, RLU-ORDO(ORDO timestamp를 사용한 RLU), Versioned-programming, SwissTM, Harris-Michael linked list, predicate-RCU(PRCU)를 선택하였다. 

![Fig3](/Data/images/02/02-02-03.png)

(그림 4)는 세 가지 자료구조에 대하여 Read-mostly, Read-intensive, Write-intensive로 구분한 마이크로 벤치마크의 성능결과를 보여준다. MV-RLU는 대부분의 경우에서 가장 우수한 성능과 확장성을 보여준다. RCU의 경우 Read-mostly 워크로드에서 MV-RLU와 유사하거나 좋은 성능을 보이는 구간이 있지만 일부이며 쓰기 연산이 많아지는 Read-intensive와 Write-intensive에서는 MV-RLU와 큰 차이로 뒤처지는 것을 볼 수 있다. Citrus나 Versioned 기법이 특정 자료구조에 대해 MV-RLU와 유사한 성능을 보이는 경우도 있지만 다른 자료구조에서는 성능이 떨어지는 현상이 발생한다. 그리고 Hash table의 경우, Write intensive 워크로드이며 448-thread 실행에서 MV-RLU가 다른 기법에 비해 최대 600배 이상의 성능 향상을 보여준다.

### 연구 결과물

본 연구결과는 멀티스레드가 공유자원을 효율적으로 접근할 수 있는 구조를 응용 소프트웨어에 제공하여 성능 향상을 도모하는 범용 프레임워크이며 직관적인 응용 프로그래밍 인터페이스 (Simple application program interface), 범용적인 프레임워크 (General framework), 다양한 자료구조 결합성 (Composability)와 같은 장점을 가진다. 따라서 멀티스레드 환경의 대부분의 응용 (예: 운영체제 커널, 파일시스템, 데이터베이스 시스템, 사용자 응용 프로그램)에서 활용 할 수 있다. 

* 논문
  - ASPLOP 2019, [MV-RLU: Scaling Read-Log-Update with Multi-Versioning](/Data/papers/02/02-02-01 MV-RLU_Scaling Read-Log-Update with Multi-Versioning.pdf)

* 공개 소프트웨어
  - Github: [MV-RLU](https://github.com/oslab-swrc/mv-rlu)
  - Github: [MV-RLU optimized B-tree](https://github.com/oslab-swrc/mv-rlu_optimized_btree)
  - Github: [MV-RLU optimized ART](https://github.com/oslab-swrc/mv-rlu_optimized_ART)
  - Github: [ORDO](https://github.com/oslab-swrc/ordo)
  - Github: [jet-KyotoCabinet](https://github.com/oslab-swrc/jet_kyotocabinet)

* 시연 동영상
  - Youtube: [Multi-Version Concurency Control for Scalable OS](https://youtu.be/c1ORPWxSV28)


## KHRONOS

### 연구 결과물

* 공개 소프트웨어
  - Github: [KHRONOS](https://github.com/oslab-swrc/KHRONOS)

* 시연 동영상
  - 


## Timestone

### 연구 배경

제안한 MV-RLU는 휘발성 메모리(DRAM)에서 동작하는 알고리즘으로 데이터 변경 내역을 관리하는 로그가 시스템의 오류나 전원차단 등으로 소실될 수 있다. 최근 컴퓨터시스템의 큰 변화중 하나는 매니코어와 함께 영구메모리를 탑재한 머신의 출시이다. 영구메모리는 바이트단위 접근과 DRAM과 유사한 성능을 제공하므로 사용자 데이터 손실을 방지할 수 있는 응용 개발에 유용하다. 하지만 높은 성능과 매니코어 확장성을 제공하기 위해서는 영구메모리 관리 소프트웨어의 지원이 반드시 필요하다. 대부분 트랜잭셔널 메모리 방식으로 사용자 데이터 복구를 지원하지만 고성능과 매니코어 확장성을 제공하는 소프트웨어 관리 기법이 전무하다. 대표적으로 인텔에서 제공하는 Persistent Memory Development Kit (PMDK) 소프트웨어는 매니코어 머신에서 성능 확장성을 전혀 제공하지 못하는 문제를 보인다. 따라서 본 논문에서는 고성능과 높은 성능 확장성을 제공하는 트랜잭셔널 메모리 소프트웨어인 TimeStone을 제안한다. 

### 연구 내용

TimeStone은 MV-RLU를 기반으로 다음의 기능을 강화하였다. 1) 영구메모리에서 쓰기 트래픽과 쓰기 증폭을 줄이기 위해서 휘발성 메모리-영구메모리 기반 하이브리드 로깅 기법을 제안하고, 2) MV-RLU 보다 강력한 일관성 모델(strong consistency model)을 제공하는 방안 제안하였다. TimeStone은 이와 같은 기능 강화를 위하여 TOC(Transient, Operational, Checkpoint) 이라는 로깅 기법을 제안하고 높은 성능 확장성과 다양한 트랙잭션 isolation level을 지원하기 위해 MV-RLU에서 사용한 MVCC 방식을 도입하였다. 

![Fig4](/Data/images/02/02-02-04.png)

(그림 3)은 TimeStone 기법에서 연결리스트 노드 삽입 시 TOC 로깅의 동작을 도시하였다. TOC 로깅은 휘발성-영구메모리의 계층화된 하이브리드 구조를 사용한다. (그림 3)에 도시된 TOC 로깅의 구조를 살펴보면, 휘발성 메모리(DRAM)을 사용하는 Transient Version Log(TLog)가 있고 아래 영구메모리를 사용하는 Operational Log(OLog)와 Checkpoint Log(CLog)가 계층화 되어 있다. TLog는 중복된 쓰기를 흡수하여 영구메모리로 가는 쓰기량을 크게 줄인다. OLog와 CLog는 사용자 데이터 복구를 위해서 사용된다. (그림 3)에서는 연결리스트에 A, B노드가 있는 상황에서 노드 C가 추가되는 경우 연산을 순서대로 도시하였다. (1) TLog에 B노드의 복사본을 생성하여 노드 C를 다음 노드로 포인팅 한다. (2) add(C) 라는 연산 명칭을 OLog에 영구메모리에 기록하여 추후 트랜잭션 복구 시 사용한다. (3)과 (5) 단계에서는 각각 OLog와 CLog의 사용량을 기록해둔다. (4) TLog를 재생하고 (6) CLog를 재생하는 절차를 통해 로그를 연속적으로 사용할 수 있다.
(그림 3)은 TimeStone 기법에서 연결리스트 노드 삽입 시 TOC 로깅의 동작을 도시하였다. TOC 로깅은 휘발성-영구메모리의 계층화된 하이브리드 구조를 사용한다. (그림 3)에 도시된 TOC 로깅의 구조를 살펴보면, 휘발성 메모리(DRAM)을 사용하는 Transient Version Log(TLog)가 있고 아래 영구메모리를 사용하는 Operational Log(OLog)와 Checkpoint Log(CLog)가 계층화 되어 있다. TLog는 중복된 쓰기를 흡수하여 영구메모리로 가는 쓰기량을 크게 줄인다. OLog와 CLog는 사용자 데이터 복구를 위해서 사용된다. (그림 3)에서는 연결리스트에 A, B노드가 있는 상황에서 노드 C가 추가되는 경우 연산을 순서대로 도시하였다. (1) TLog에 B노드의 복사본을 생성하여 노드 C를 다음 노드로 포인팅 한다. (2) add(C) 라는 연산 명칭을 OLog에 영구메모리에 기록하여 추후 트랜잭션 복구 시 사용한다. (3)과 (5) 단계에서는 각각 OLog와 CLog의 사용량을 기록해둔다. (4) TLog를 재생하고 (6) CLog를 재생하는 절차를 통해 로그를 연속적으로 사용할 수 있다.

### 성능 실험

(그림 3)은 TimeStone 기법에서 연결리스트 노드 삽입 시 TOC 로깅의 동작을 도시하였다. TOC 로깅은 휘발성-영구메모리의 계층화된 하이브리드 구조를 사용한다. (그림 3)에 도시된 TOC 로깅의 구조를 살펴보면, 휘발성 메모리(DRAM)을 사용하는 Transient Version Log(TLog)가 있고 아래 영구메모리를 사용하는 Operational Log(OLog)와 Checkpoint Log(CLog)가 계층화 되어 있다. TLog는 중복된 쓰기를 흡수하여 영구메모리로 가는 쓰기량을 크게 줄인다. OLog와 CLog는 사용자 데이터 복구를 위해서 사용된다. (그림 3)에서는 연결리스트에 A, B노드가 있는 상황에서 노드 C가 추가되는 경우 연산을 순서대로 도시하였다. (1) TLog에 B노드의 복사본을 생성하여 노드 C를 다음 노드로 포인팅 한다. (2) add(C) 라는 연산 명칭을 OLog에 영구메모리에 기록하여 추후 트랜잭션 복구 시 사용한다. (3)과 (5) 단계에서는 각각 OLog와 CLog의 사용량을 기록해둔다. (4) TLog를 재생하고 (6) CLog를 재생하는 절차를 통해 로그를 연속적으로 사용할 수 있다.

![Fig5](/Data/images/02/02-02-05.png)

(그림 5)는 MV-RLU와 동일한 세 가지 자료구조에 대하여 Read-mostly, Read-intensive, Write-intensive로 구분한 마이크로 벤치마크의 성능결과를 보여준다. TimeStone은 대부분의 경우에서 가장 우수한 성능과 확장성을 보여준다. Romulus의 경우 Linked list 자료구조 Read-mostly에서만 가장 좋은 성능을 보일뿐 나머지 경우 TimeStone이 가장 좋은 성능을 보인다. Hash table의 경우 TimeStone이 다른 기법에 비해 최대 30배 이상의 성능 향상을 보이고 선형적인 성능 확장성을 보였다.

### 연구 결과물

* 논문
  - ASPLOS 2020, [Durable Transactional Memory Can Scale with Timestone](/Data/papers/02/02-02-02 Durable Transactional Memory Can Scale with Timestone.pdf) 

* 공개 소프트웨어
  - Github: [Timestone](https://github.com/oslab-swrc/timestone)
  - Github: [Timestone optimized B-tree](https://github.com/oslab-swrc/timestone_optimized_btree)

* 시연 동영상
  - [비휘발성 메모리 기반 고성능 데이터베이스 서비스](/Data/videos/비휘발성 메모리 기반 고성능 데이터베이스 서비스 TimeStone.mp4)
  - Youtube: [Highly Scalable Durable Database Service](https://youtu.be/TcRlPbnuhU8)
